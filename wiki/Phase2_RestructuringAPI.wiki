#summary Explaining how the API structure has changed

= Initial implementation =

 * We had a [http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADType/GraphADT.java?r=129 GraphADT] abstract class, and three sub-classes ([http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADType/GraphMapAdj.java?r=129 MapAdj], [http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADType/GraphMapSucc.java?r=129 MapSucc] and [http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADType/GraphArraySucc.java?r=129 ArraySucc]) that extended it. 
 * We had implementation problems like:
   # inefficient and overloaded methods: for instance, the _getEdges_ method (that returns all edges in the graph) was based on another method _getNeighborEdges_ called for every node in graph *AND* it was defined in the abstract class therefore not taking advantages the some structure graph implementations may offer.
   # The distinction of an *Undirected* and a *Directed* graph was done naively: for instance, the undirected graph had the repeated edges (like _A->B_ and _B->A_) represented in memory
 * At a very early stage we has several conceptual problems like:
   # Encapsulating the node data/id in a Node class
   # Encapsulating (thus, *restricting*) the connection info inside the Edge class: source and target nodes were stored inside an edge

= _myNewLib_ implementation =
The general structure of the API was redefined after studying the JUNG and JGraph implementations.
 * The most important methods are now implemented *at a lower level* (like the _getEdges_ example)

 * *Tagging interfaces* were added to better represent Undirected and Directed graphs (tagging interfaces will also be applied to other matters)

 * An _experimental_ controlling mechanism for visited vertices and edges was added: the class [http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADT_2nd_try/UndirectedColoredGraph.java?r=132 UndirectedColoredGraph] (extends [http://code.google.com/p/ugl-uminho-cpd/source/browse/trunk/Graphs/src/GraphADT_2nd_try/UndirectedGraph.java?r=132 UndirectedGraph]) works very well bypassing the need of using an array to control the visited nodes.

 * I think the main improvement made, besides the new structure, was the *decapsulation* of data:
   # the node info is not encapsulated in a specific _Node_ class as before
   # *and the most important*, the edge info is now treated by the API as a generic _E_, instead of innerly processing the edge with the class _Edge_. Also, the graph uses two structures: *(i)* one to store the nodes and map each node to an edge (of type _E_), and *(ii)* another structure to map each edge to the node endpoints - this approach is not so rigid as using only one structure. By using two structures, searching in the graph will be much more straight-forward.

=Benchmarks: myNewLib, JUNG and JGraph=
The reformulated API showed lots of improvement in performance. A second chart with lines was added for better understanding which implementation is best at each _node count_.

No special measuring schemes and methodologies were followed, except the best times out of three executions.
==Prim algorithm==
_Note the logarithmic scale_

|| http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/prim_myNewLib.png || http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/prim_myNewLib_lines.png ||

==Kruskal algorithm==

|| http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/kruskal_myNewLib.png || http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/kruskal_myNewLib_lines.png ||

==Boruvka algorithm==

|| http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/boruvka_myNewLib.png || http://ugl-uminho-cpd.googlecode.com/svn-history/r129/trunk/Graphs/images/boruvka_myNewLib_lines.png ||