#summary Explaining Boruvka's minimum spanning tree algorithm

= Boruvka MST =

The implementation of this algorithm uses three main concepts:
 * *wannabe edges*: a collection of edges that are not yet in the MST and not yet processed by the algorithm
 * *smallest neighbor map*: a map containing all nodes in the graph has _keys_ and their smallest associated edges has _values_ (at the beginning of each iteration the edge will be maximum).
 * *a forest* (UnionFind_ADT): the forest is a group of trees (initially, each node is a tree) used to keep track of the MST structure, the algorithm has found the MST graph when there is only one tree in the forest.

Simply put, Boruvka's algorithm, runs through every node in the graph and searches for the minimum edge associated to it - the structure where we store this is `nbors`. However, at first we do not explicitly iterate through all the nodes - we iterate through the available edges (`wannabe` edges). We need to build the `nbors` map at each new iteration and then we run through every node and (if they are not in the same tree in the forest, in case there are ) the minimum edge associated with it is added.

{{{
        for (int i = g.size(); i != 0; i = nextIteration) {
            nbors = ...// new neighbors map
            // edges to add found in this iteration
            edges2add = new ArrayList<EdgeEO<T, Y>>();
            Node source, target;
            nextIteration = 0;
            for (EdgeEO<T, Y> edge : wannabes) {
                // get both nodes of the edge and then see if they have already found a smaller edge (in 'nbors' map)
                l = union_find.find(edge.getSourceNode());
                m = union_find.find(edge.getTargetNode());
                if (source.equals(target)) { // it means the node are already in the same tree in the forest - ignore this edge
                    continue;
                }
                // if the weight of the current edge is lower than the one stored for 'l'...
                if (edge.getWeight() < nbors.get(source).getWeight()) {
                    nbors.put(source, edge);
                }
                if (edge.getWeight() < nbors.get(target).getWeight()) {
                    nbors.put(target, edge);
                }
                nextIteration++;
            }
            // for every vertex check its nearest neighbor
            for (Node<T> node : allnodes) {
                if (nbors.get(node).getWeight() < MaxEdgeWeight) {
                    EdgeEO<T, Y> nEdge = nbors.get(node);
                    source = nEdge.getSourceNode();
                    target = nEdge.getTargetNode();
                    // if 'source' and 'target' don't have the same root they are in a different tree...
                    //if so, rearrange forest and add it this edge to MST
                    if (!g._union_find.find(source, target)) {
                        g._union_find.union(source, target); //...rearrange forest
                        edges2add.add(nEdge);                //...add this edge to MST
                    }
                }
            }
            // remove wannabe edges that are already in the MST
            wannabes.removeAll(edges2add);
            mstEdges.addAll(edges2add);
        }
}}}


http://ugl-uminho-cpd.googlecode.com/svn/trunk/Graphs/images/graph_image.png