#summary Explaining Boruvka's minimum spanning tree algorithm

= Boruvka MST =

The implementation of this algorithm uses three main concepts:
 * *wannabe edges*: a collection of edges that are not yet in the MST and not yet processed by the algorithm
 * *smallest neighbor map*: a map containing all nodes in the graph has _keys_ and their smallest associated edges has _values_ (at the beginning of each iteration the edge will be maximum).
 * *a forest* (UnionFind_ADT): the forest is a group of trees (initially, each node is a tree) used to keep track of the MST structure, the algorithm has found the MST graph when there is only one tree in the forest.

Simply put, Boruvka's algorithm, runs through every node in the graph and searches for the minimum edge associated to it - the structure where we store this is `nbors`. However, at first we do not explicitly iterate through all the nodes - we iterate through the available edges (`wannabe` edges). We need to build the `nbors` map at each new iteration and then we run through every node and (if they are not in the same tree in the forest, in case there are ) the minimum edge associated with it is added.

{{{
        for (int i = g.size(); i != 0; i = nextIteration) {
            nbors = ...// new neighbors map
            // edges to add found in this iteration
            edges2add = new ArrayList<EdgeEO<T, Y>>();
            Node source, target;
            nextIteration = 0;
            for (EdgeEO<T, Y> edge : wannabes) {
                // get both nodes of the edge and then see if they have already found a smaller edge (in 'nbors' map)
                source = union_find.find(edge.getSourceNode());
                target = union_find.find(edge.getTargetNode());
                if (source.equals(target)) { // it means the node are already in the same tree in the forest - ignore this edge
                    continue;
                }
                // if the weight of the current edge is lower than the one stored for 'l'...
                if (edge.getWeight() < nbors.get(source).getWeight()) {
                    nbors.put(source, edge);
                }
                if (edge.getWeight() < nbors.get(target).getWeight()) {
                    nbors.put(target, edge);
                }
                nextIteration++;
            }
            // for every vertex check its nearest neighbor
            for (Node<T> node : allnodes) {
                if (nbors.get(node).getWeight() < MaxEdgeWeight) {
                    EdgeEO<T, Y> nEdge = nbors.get(node);
                    source = nEdge.getSourceNode();
                    target = nEdge.getTargetNode();
                    // if 'source' and 'target' don't have the same root they are in a different tree...
                    // if so, rearrange forest and add this edge to MST
                    if (!g._union_find.find(source, target)) {
                        g._union_find.union(source, target); //...rearrange forest
                        edges2add.add(nEdge);                //...add this edge to MST
                    }
                }
            }
            // remove wannabe edges that are already in the MST
            wannabes.removeAll(edges2add);
            mstEdges.addAll(edges2add);
        }
}}}

This implementation may still be altered because it doesn't makes use of too many accesses to the graph data-structure (or graph API) - which is not necessarily bad. The accesses this specific algorithm performs to the structure are:
 * initialize the _wannabe_ edge list: it needs to access the graph data-structure to get all possible edges 
 * initialize the forest: with all the nodes in the graph (`UnionFind` structure is inside the graph structure)
 * for this specific API, the edges contain both the nodes that are linked, but in some libraries it only stores the edge value/data or weight. For those libraries, at each _wannabe iteration_ (inner cycle) the algorithm accesses the graph structure in order to get the nodes and process them in the forest.
 * retrieve all nodes at the end of each outer iteration: however the nodes may only be accessed once in the beginning of the algorithm and stored in a list (`allnodes`).

http://ugl-uminho-cpd.googlecode.com/svn/trunk/Graphs/images/graph_image.png