#summary Explaining Boruvka's minimum spanning tree algorithm

= Boruvka MST =

The implementation of this algorithm uses three main concepts:
 * *wannabe edges*: a collection of edges that are not yet in the MST and not yet processed by the algorithm
 * *smallest neighbor map*: a map containing all nodes in the graph has _keys_ and their smallest associated edges has _values_ (at the beginning of each iteration the edge will be maximum).
 * *a forest* (UnionFind_ADT): the forest is a group of trees (initially, each node is a tree) used to keep track of the MST structure, the algorithm has found the MST graph when there is only one tree in the forest.

Simply put, Boruvka's algorithm, runs through every node in the graph and searches for the minimum edge associated to it - the structure where we store this is `nbors`. However, at first we do not explicitly iterate through all the nodes - we iterate through the available edges (`wannabe` edges). We need to build the `nbors` map at each new iteration and then we run through every node and (if they are not in the same tree in the forest, in case there are ) the minimum edge associated with it is added.

{{{
    public GraphADT getMst(GraphADT G) {
        Graph MST           = ...// new empty MST graph
        List<Edge> mstEdges = ...// initialize empty list of mst edges to add
        List<Edge> wannabes = ...// get wannabe edges in MST from original graph
        G.initUnionFind();       // build control forest
        // initialize forest (nbors hashmap - each node is initially a root)
        HashMap<Node, Edge> nbors = new HashMap<Node, Edge>(G.getNumNodes);
        List<Node> allnodes = G.getAllNodes();
        // the nextIteration variable controls if any wannabe was processed
        // - if it wasnt, no more wannabes means stop
        // - if wannabes were processed keep on to next iteration
        int nextIteration;
        // Repeat until there is only one tree
        for (int i = G.getNumEdges i != 0; i = nextIteration) {
            // initialize each node's minEdge with null - which will correspond to the maximum edge
            for (Node node : allnodes) {
                nbors.put(node, null);
            }
            // edges to add found in this iteration
            List<Edge> edges2add = ...// new empty list of edges to add found in this iteration
            Node node1, node2;
            nextIteration = 0;
            for (EdgeEO<T, Y> edge : wannabes) {
                // get both nodes of the edge and then see if they have already found a smaller edge (in 'nbors' map)
                node1 = G._union_find.getRootOf( edge.getSourceNode() );
                node2 = G._union_find.getRootOf( edge.getTargetNode() );
                // if they are equal => they are the same root - dont add edge otherwise we would have a cycle
                if (node1 != node2) {
                    continue;
                }
                if ( edge.getWeight() < nbors.get(node1).getWeight() ) {
                    nbors.put(node1, edge);
                }
                if ( edge.getWeight() < nbors.get(node2).getWeight() ) {
                    nbors.put(node2, edge);
                }
                nextIteration++; // increment - this means edges were processed
            }
            // for every vertex check its nearest neighbor
            for (Node node : allnodes) {
                if (nbors.get(n) != null) {
                    Edge nEdge = nbors.get(node);
                    node1 = nEdge.getSourceNode();
                    node2 = nEdge.getTargetNode();
                    if (G._union_find.NotSameRoot( node1, node2) ) {
                        g._union_find.Union(node1, node2);
                        edges2add.add(nEdge);
                    }
                }
            }
            // remove wannabe edges that are already in the MST
            wannabes.removeAll(edges2add);
            mstEdges.addAll(edges2add);
        }
        // build graph of same type and fill it with the MST info
        
        
        MST.addAllEdges(mstEdges);
        return MST;
    }
}}}

This implementation may still be altered because it doesn't makes use of too many accesses to the graph data-structure (or graph API) - which is not necessarily bad. The accesses this specific algorithm performs to the structure are:
 * initialize the _wannabe_ edge list: it needs to access the graph data-structure to get all possible edges 
 * initialize the forest: with all the nodes in the graph (`UnionFind` structure is inside the graph structure)
 * for this specific API, the edges contain both the nodes that are linked, but in some libraries it only stores the edge value/data or weight. For those libraries, at each _wannabe iteration_ (inner cycle) the algorithm accesses the graph structure in order to get the source and target nodes and process them in the forest.
 * retrieve all nodes at the end of each outer iteration: however the nodes may only be accessed once in the beginning of the algorithm and stored in a list (`allnodes`).

http://ugl-uminho-cpd.googlecode.com/svn/trunk/Graphs/images/graph_image.png